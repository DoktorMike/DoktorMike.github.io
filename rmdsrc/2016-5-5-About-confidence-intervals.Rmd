---
title: "About confidence intervals"
author: "Dr. Michael Green"
date: "May 5, 2016"
output: html_document
layout: post
published: false
status: publish
use_math: true
---


```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(rstan)
library(ggplot2)
library(dplyr)
library(tidyr)
library(scales)
rstan_options(auto_write = TRUE)
```

# Introduction

Confidence intervals are as beautiful as they are deceiving. They're part of an elegant theory of mathematical statistics which has been abused since the dawn of time. Why do I say abused? Well quite frankly because literally everyone gets it wrong.. Now in order to subsantiate my claims let's have a look at what the confidence interval really is mathematically by inspecting the following formula

$$P_\theta\left(a(X)<\theta<b(X)\right)=\gamma,\, \forall \theta \in \mathbb{R}$$

where $$X$$ is a **random** sample describing data generated by a process controlled by a **fixed** parameter $$\theta$$. The $$\gamma$$ is the desired confidence level meanwhile the functions $$a$$ and $$b$$ are the lower and upper functions generating the boundary of the interval for a **random** sample. So what does this equation really say? Glad you asked, it states the following:

> For a random sample of the data, the confidence interval as defined by the random variables $$a$$ and $$b$$ will contain the true value of the parameter $$\theta$$ with a probability of $$\gamma$$.

An interesting thing about this interval is that it by design has to contain the unknown fixed parameter $$\theta$$, no matter what that value might be, with a probability of $$\gamma$$ across all sampled data sets. It does **NOT**, however, say that the probability that the true value of $$\theta$$ for a realized data sample lies in the interval calculated for that very sample! Ok, fine! So then why do we state it probabalistically? The answer to this is also simple, because we are stating a probability distribution over random samples of $$X$$ controlled by the parameter $$\theta$$. Once we have observed (sampled) a specific realization of that data the probability is gone. The only thing you can state after observing the data, in this setting, is

> The realized interval at hand either contains the true value of the parameter or it does not.

That's it folks, there is nothing more you can say about that. Thus, the conclusion here is that confidence intervals only speak about probabilities for repeated samples and measurements of the parameter of interest. In other words, the probability distribution is over the data and not the parameter.

Now don't get me wrong, this is a really useful tool to have in your statistical toolbox and will for sure be helpful when you have access to multiple data sets measuring the same phenonemna. However, if you have just one realized data set, then a confidence interval is hardly what you want to express to yourself or others as a finding. 


## The remedy
Since we just loooked at the problems with the confidence interval you might wonder what we could do instead to quantify the uncertainty of our estimate given the data we currently do have. It turns out that we can use the same starting point as before but instead of viewing the data as random, we consider instead the parameter $$\theta$$ to be random and the data to be observed and fixed. This means that the interval now becomes

$$P_\theta\left(a(x)<\Theta<b(x)\,\middle |\,X=x\right)=\gamma$$

which expresses uncertainty in what we are actually interested in measuring. To not confuse it with the confidence interval I'll use the $$\Theta$$ as the parameter of interest to highlight that it's the focal point of the distribution. In addition I'll call this the **credibility interval** instead. This is not my notation but widely used terminology. Now, we have a very natural way to relate the outcome to probability. We could for example set the degree of belief to 90\% and say the following:

> The degree of my belief that the parameter is indeed in this interval is 90\%.

As previously mentioned, this statement is reserved for credibility intervals and cannot, I reapeat, **cannot** be used in the setting of a confidence interval. Do not rest your minds until you understand this. 

# A simple polynomial regression example

If we take a look at a simple polynomial example we can illustrate some differences and similarities between the two approaches. In this scenario we have a noise model $$y\sim\mathcal{N}\left(-2x^2+200x+1000, 30\sigma_x\right)$$ which is depicted below for 100 samples. The blue dots are the measured noisy samples, while the red dots are the "truth".

```{r datablock, echo=FALSE, message=FALSE, warning=FALSE, cache=FALSE}
gendata<-function(){
  x <- 1:100
  y <- -2*x^2+200*x+1000+rnorm(length(x), 0, 30*sd(x))
  data.frame(y, x)
}

fitmodel<-function(data=gendata()){
  mylm<-lm(y~I(x**2)+x, data=data)
  mylm
}

mydf<-gendata()
mylm<-fitmodel(mydf)
# summary(mylm)
mydf %>% mutate(truth=-2*x**2+200*x+1000) %>% gather(Type, Value, -x) %>% ggplot(aes(y=Value, x=x, color=Type)) + geom_point() + geom_smooth(level=0.999) + theme_minimal()
```

The question now is how a normal linear regression and a bayesian linear regression, with uninformative priors, handle this and what the inference about the sought parameters might be. Let's start by looking at what our linear regression model finds in comparison to the Bayesian approach.

```{r lmvsstaninterval, message=FALSE, warning=FALSE, cache=TRUE, include=FALSE}
#options(mc.cores = parallel::detectCores())

stancode<-"
data {
  int<lower=0> N;
  real<lower=0> x[N];
  real y[N];
}
parameters {
  real b_0;
  real b_x;
  real b_xx;
  real<lower=0> sigma;
}
model {
  for(i in 1:N){
    y[i] ~ normal(b_x*x[i] + b_xx*x[i]*x[i] + b_0, sigma);
  }
}
generated quantities {
  real yhat[N];
  for(i in 1:N){
    yhat[i] <- normal_rng(b_x*x[i] + b_xx*x[i]*x[i] + b_0, sigma);
  }
}
"

mydf<-gendata()
mylm<-fitmodel(mydf)
sfit<-stan(model_code = stancode, data = list(N=nrow(mydf), y=mydf$y, x=mydf$x), 
             chains = 1, iter = 700, warmup = 300, cores = 1, init = "random", 
             algorithm = "NUTS")
sfitdf<-as.data.frame(sfit)
```

```{r lmresults, echo=FALSE, warning=FALSE, message=FALSE}
a<-data.frame(round(confint(mylm),2), round(coef(mylm), 2))
colnames(a)<-c("lower", "upper", "mean")
b<-t(round(sapply(c("b_0", "b_x", "b_xx"), function(x) quantile(sfitdf[,x], probs=c(0.025, 0.975, 0.5))), 2))
```

Parameter     | Freq                                   | Bayes
------------- | -------------------------------------- | -----------
Intercept     | `r a[1,3]` (`r a[1,1]`, `r a[1,2]`)    | `r b[1,3]` (`r b[1,1]`, `r b[1,2]`)
X             | `r a[3,3]` (`r a[3,1]`, `r a[3,2]`)    | `r b[2,3]` (`r b[2,1]`, `r b[2,2]`)
X^2^          | `r a[2,3]` (`r a[2,1]`, `r a[2,2]`)    | `r b[3,3]` (`r b[3,1]`, `r b[3,2]`)

Well hang on a moment, these results are as far as I can see more or less identical! Indeed you are right, as you might recall I did say that we were doing a non-informative Bayes linear regression which means that all of our parameters were fed with uniform non-informative priors. It's rather obvious that there's really no qualitative difference between the confidence intervals created by the frequentist approach and the credibility intervals created by the Bayesian approach. Does this mean that they are the same? Well, no. They are the same because in our first attempt at being Bayesian we assumed flat uniform priors which means that we provided purely non-informative priors. As such the Bayesian approach is purely data driven which means that the likelihood determines everything. This illustrates nicely the point that maximum likelihood for a linear model is just a special case of the fully Bayeian model with uniform priors.

If we investigate one of the parameters more closely we can see that the intercept term is way off. It should be 1000 but is much lower in the estimates. The reason for this is the random noise that was added of course. But even so, couldn't we do better? Yes we can. We can look at the data and see that it looks like it's peaking at x=50 so let's put a prior on our parameters reflecting that belief. The new results for Bayes2 is given below. 

```{r staninterval2, message=FALSE, warning=FALSE, cache=TRUE, include=FALSE}
#options(mc.cores = parallel::detectCores())

stancode<-"
data {
  int<lower=0> N;
  real<lower=0> x[N];
  real y[N];
}
parameters {
  real b_0;
  real b_x;
  real<lower=0.1> sigma;
}
transformed parameters{
  real b_xx;
  b_xx <- b_x * -1 / 100;
}
model {
  sigma ~ normal(1000, 400);
  for(i in 1:N){
    y[i] ~ normal(b_x*x[i] + b_xx*x[i]*x[i] + b_0, sigma);
  }
}
generated quantities {
  real yhat[N];
  for(i in 1:N){
    yhat[i] <- normal_rng(b_x*x[i] + b_xx*x[i]*x[i] + b_0, sigma);
  }
}
"

sfit<-stan(model_code = stancode, data = list(N=nrow(mydf), y=mydf$y, x=mydf$x), 
             chains = 1, iter = 700, warmup = 300, cores = 1, init = "random", 
             algorithm = "NUTS")
sfitdf2<-as.data.frame(sfit)
```

```{r stanresults2, echo=FALSE, warning=FALSE, message=FALSE}
b<-t(round(sapply(c("b_0", "b_x", "b_xx"), function(x) quantile(sfitdf2[,x], probs=c(0.025, 0.975, 0.5))), 2))
```

Parameter     | Freq                                   | Bayes 2
------------- | -------------------------------------- | -----------
Intercept     | `r a[1,3]` (`r a[1,1]`, `r a[1,2]`)    | `r b[1,3]` (`r b[1,1]`, `r b[1,2]`)
X             | `r a[3,3]` (`r a[3,1]`, `r a[3,2]`)    | `r b[2,3]` (`r b[2,1]`, `r b[2,2]`)
X^2^          | `r a[2,3]` (`r a[2,1]`, `r a[2,2]`)    | `r b[3,3]` (`r b[3,1]`, `r b[3,2]`)

Now it's quite apparent to see that we are in much better shape regarding the intercept term while the other estimates stayed more or less in the same range. They were also never bad to begin with. 

## Repeated measurements

Let's see what happens if we repeat the analysis 100 times. In this scenario we have 100 researchers with 100 realized data sets from the same underlying process. How will their inferences look?

```{r sampleit, echo=FALSE, message=FALSE, warning=FALSE, include=FALSE}
n<-100
tmpdf<-data.frame(lower=numeric(n), mean=numeric(n), upper=numeric(n))
for(i in 1:n){
  mydf<-gendata()
  mylm<-fitmodel(mydf)
  myconf<-confint(mylm)
  paramind<-1
  tmpdf$lower[i]<-myconf[paramind, 1]
  tmpdf$upper[i]<-myconf[paramind, 2]
  tmpdf$mean[i]<-coef(mylm)[paramind]
}
tmpdf %>% gather(Distribution, Estimate) %>% ggplot(aes(x=Estimate, fill=Distribution)) + geom_density(alpha=0.7) + theme_minimal() + scale_fill_brewer(type="seq", palette = 2) + ylab("Density")
tmpdf %>% gather(Distribution, Estimate) %>% ggplot(aes(y=Estimate, x=Distribution, fill=Distribution)) + geom_violin() + theme_minimal() + scale_fill_brewer(type="seq", palette = 2) + ylab("Estimate")
```

```{r stanmodel, message=FALSE, warning=FALSE, cache=TRUE, include=FALSE}
library(rstan)
rstan_options(auto_write = TRUE)
#options(mc.cores = parallel::detectCores())

stancode<-"
data {
  int<lower=0> N;
  real<lower=0> x[N];
  real y[N];
}
parameters {
  real b_0;
  real b_x;
  real<lower=0.1> sigma;
}
transformed parameters{
  real b_xx;
  b_xx <- b_x * -1 / 100;
}
model {
  sigma ~ normal(1000, 400);
  for(i in 1:N){
    y[i] ~ normal(b_x*x[i] + b_xx*x[i]*x[i] + b_0, sigma);
  }
}
generated quantities {
  real yhat[N];
  for(i in 1:N){
    yhat[i] <- normal_rng(b_x*x[i] + b_xx*x[i]*x[i] + b_0, sigma);
  }
}
"

n<-100
tmpdf2<-data.frame(lower=numeric(n), mean=numeric(n), upper=numeric(n))

for(i in 1:n){
  mydf<-gendata()
  sfit<-stan(model_code = stancode, data = list(N=nrow(mydf), y=mydf$y, x=mydf$x), 
             chains = 1, iter = 700, warmup = 300, cores = 1, init = "random", 
             algorithm = "NUTS")
  sfitdf<-as.data.frame(sfit)
  tmpdf2[i, ]<-quantile(sfitdf$b_0, probs=c(1-0.975, 0.5, 0.975))
}

tmpdf2 %>% gather(Distribution, Estimate) %>% ggplot(aes(x=Estimate, fill=Distribution)) + geom_density(alpha=0.7) + theme_minimal() + scale_fill_brewer(type="seq", palette = 2) + ylab("Density")
tmpdf2 %>% gather(Distribution, Estimate) %>% ggplot(aes(y=Estimate, x=Distribution, fill=Distribution)) + geom_violin() + theme_minimal() + scale_fill_brewer(type="seq", palette = 2) + ylab("Estimate")
```

```{r confidencefreq1, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE}
tmpdf %>% mutate(Run=1:nrow(tmpdf)) %>% ggplot(aes(Run, mean)) + geom_pointrange(aes(ymin=lower, ymax=upper)) + coord_flip() + theme_minimal() 
```

```{r confidencebayes1, echo=FALSE, message=FALSE, warning=FALSE, eval=FALSE}
tmpdf2 %>% mutate(Run=1:nrow(tmpdf2)) %>% ggplot(aes(Run, mean)) + geom_pointrange(aes(ymin=lower, ymax=upper)) + coord_flip() + theme_minimal() 
```

```{r confidencebayesandfreq1, echo=FALSE, message=FALSE, warning=FALSE}
rbind(data.frame(Type="Bayes", Run=1:nrow(tmpdf2), tmpdf2), data.frame(Type="Freq", Run=1:nrow(tmpdf), tmpdf)) %>% ggplot(aes(Run, mean)) + geom_pointrange(aes(ymin=lower, ymax=upper)) + facet_grid(~Type) + theme_minimal() + ylab("Estimate") 
```

The uncertainty, of the confidence interval for the freqeuntist approach and of the parameter estimate in the Bays 2 model are rather different. The prior we added to the Bayes model obviously helps us in making educated inferences about the true parameter value. The variation of the estimated parameter is `r round(1-sd(tmpdf2$mean)/sd(tmpdf$mean),2)*100` per cent lower for the Bayes 2 model compared to the frequentist approach. Further the average difference between the upper and lower limits is `r round(1-mean(tmpdf2$upper-tmpdf2$lower)/mean(tmpdf$upper-tmpdf$lower), 2)*100` per cent lower for the Bayes 2 model.

# Summary
So let's round this up by stating that confidence intervals are useful nifty little things that are exceedingly open to misinterpretation. Use them if you want to but make sure you understand them. The following little list is useful to remember.

- A confidence interval does not say anything about the probability of the sought parameter to be inside a specific interval
- A confidence interval is a probability distribution over the data generated by a fixed parameter and not over the parameter
- Once a confidence interval has been realized (measured) by observing data it is no longer a probability; it either contains the parameter value sought or it does not

```{r predictsfit, echo=FALSE, warning=FALSE, message=FALSE, eval=FALSE}
predictsfit<-function(sfitdf, data, samples=10)
{
  preddf<-data
  x<-data$x
  for(i in sample(1:nrow(sfitdf), samples)){
    preddf[, paste0("yhat",i)]<-sfitdf[i, "b_xx"]*x**2 + sfitdf[i, "b_x"]*x + sfitdf[i, "b_0"]
  }
  preddf$ytrue <- -2*x**2+200*x+1000
  preddf$y<-NULL
  preddf
}

predictsfit(sfitdf, mydf, 20) %>% gather(Model, Prediction, -x) %>% ggplot(aes(x=x, y=Prediction, color=Model)) + geom_line() + geom_point(data=mydf, aes(x=x, y=y, color=NULL)) + theme_minimal()
```
